function (triggerId, reason)
    debug("newChar system initiated. Reason: " .. (reason or "unknown"))
    
    -- 1. 설정 및 데이터 로드
    local raceDB = getDB(triggerId, "race.db")
    local classDB = getDB(triggerId, "class.db")
    local traitDB = getDB(triggerId, "trait.db")
    local expTable = getDB(triggerId, "EXPtable.db") -- EXPtable은 아직 변환 안했을 수 있음. 확인 필요하나 일단 진행.
    -- EXPtable.db 파일은 언급된 적 없으므로 패스하거나 기존대로. (오류나면 수정)
    
    local dungeonLv = tonumber(getChatVar(triggerId, "dungeonLv") or 1)
    local ageLimit = tonumber(getChatVar(triggerId, "ageLimit") or 12)
    local raceLimit = getChatVar(triggerId, "raceLimit") or "0" 
    local maleLimit = getChatVar(triggerId, "maleLimit") or "0"
    local futaLimit = getChatVar(triggerId, "futaLimit") or "0"
    local heroLvLimit = tonumber(getChatVar(triggerId, "heroLvLimit") or 5)
    
    -- 2. 기본 골격 생성 (RNG)
    math.randomseed(os.time())
    
    local level = math.max(1, dungeonLv + math.random(-2, heroLvLimit))
    
    -- 종족 결정
    local raceListKey = json.decode(getChatVar(triggerId, "raceList"))
    local raceKey = ""
    local raceData = {}
    
    if raceLimit == "1" then -- 인간만
        raceKey = "human"
    else
        raceKey = raceListKey[math.random(#raceListKey)]
    end
    raceData = raceDB[raceKey] -- 객체 구조
    -- 혹시 데이터 없으면 인간으로 폴백
    if not raceData then raceKey = "human"; raceData = raceDB["human"] end


    -- 클래스 결정
    local classListKey = json.decode(getChatVar(triggerId, "classList"))
    local classKey = classListKey[math.random(#classListKey)]
    local classData = classDB[classKey]

    -- 성별 결정
    local genderPool = {"여성", "여성", "여성"} 
    if maleLimit == "1" then table.insert(genderPool, "남성") end
    if futaLimit == "1" then table.insert(genderPool, "후타나리") end
    local gender = genderPool[math.random(#genderPool)]
    
    -- 나이 결정
    local ageBase = math.max(ageLimit, 8)
    local lifeSpanMult = raceData.life_mod or 1.0 -- 필드명 변경 반영
    local age = math.floor((ageBase + math.random(0, 10)) * lifeSpanMult)
    if age < ageLimit then age = ageLimit end
    
    -- 3. 스탯 계산
    local baseHP = 100
    local baseSP = 100
    
    local hpMult = (raceData.hp_mod or 1.0) * (classData.hp_growth or 1.0)
    local spMult = (raceData.sp_mod or 1.0) * (classData.sp_growth or 1.0)
    -- atk, def 모드는 classData에 있음
    
    local maxHP = math.floor((baseHP + (level * 15)) * hpMult * (math.random(90, 110)*0.01))
    local maxSP = math.floor((baseSP + (level * 10)) * spMult * (math.random(90, 110)*0.01))
    
    -- 초기 전투 스탯 (임시)
    local atk = math.floor(10 * level * (classData.atk_mod or 1.0))
    local def = math.floor(10 * level * (classData.def_mod or 1.0))
    local combatRating = math.floor((atk + def) * 0.5)

    -- 신체 사이즈
    local heightBase = raceData.height or 160
    local height = math.floor(heightBase + math.random(-10, 10))
    local weight = math.floor((height - 100) * 0.9 * (math.random(90, 110)/100))
    
    local bust = "평범"
    local nipple = "갈색"
    local penis = ""
    local pubes = "보통"
    
    if gender ~= "남성" then
        local bustSizes = {"절벽", "빈유", "평범", "거유", "폭유"}
        bust = bustSizes[math.random(#bustSizes)]
    end
    
    if gender ~= "여성" then
        local penisSizes = {"실좆", "작음", "평범", "대물", "말자지"}
        penis = penisSizes[math.random(#penisSizes)]
    end
    
    -- 4. 특성(Trait) 부여 (영문 키 선택 -> 한글 이름 매핑)
    local personalityList = json.decode(getChatVar(triggerId, "성격List"))
    local bodyTraitList = json.decode(getChatVar(triggerId, "신체특성List"))
    
    local assignedTraitsKey = {}
    
    -- 성격 1~2개 (Group 충돌 방지 로직은 여기서 간단히 처리 - 같은 그룹이면 스킵)
    local function addTrait(list)
        local key = list[math.random(#list)]
        -- 이미 있는지, 그룹 충돌하는지 체크
        -- 여기선 단순하게 중복만 체크
        local dup = false
        for _, k in ipairs(assignedTraitsKey) do if k == key then dup = true; break end end
        if not dup then table.insert(assignedTraitsKey, key) end
    end
    
    addTrait(personalityList)
    if math.random() > 0.5 then addTrait(personalityList) end
    
    -- 신체특성 추가
    if math.random() > 0.7 then addTrait(bodyTraitList) end
    
    -- 종족 특성 추가 (raceDB의 traits필드는 한글 이름으로 되어있음... DB구조 확인필요)
    -- 아까 race.db 변환할 때: "traits": {"V명기": 2, ...} 로 한글 키 유지했음!
    -- 따라서 종족 특성은 별도 처리 필요.
    local raceTraits = raceData.traits or {}
    local raceTraitKeys = {} --한글임
    for k, v in pairs(raceTraits) do
        table.insert(raceTraitKeys, k)
    end
    
    
    
    -- 5. 스켈레톤 데이터 구성 (한글 키 매핑)
    local skeleton = {
        ["종족"] = raceData.name, -- "인간"
        ["성별"] = gender,
        ["나이"] = tostring(age),
        ["클래스"] = classData.name, -- "기사"
        ["레벨"] = tostring(level),
        ["경험치"] = "0",
        
        ["체력"] = tostring(maxHP),
        ["최대체력"] = tostring(maxHP),
        ["기력"] = tostring(maxSP),
        ["최대기력"] = tostring(maxSP),
        ["공격력"] = atk,
        ["방어력"] = def,
        ["레이팅"] = combatRating,
        
        ["자궁정액"]="0",
        ["애널정액"]="0",
        ["condition"] = "조교가능",

        ["키"] = tostring(height),
        ["몸무게"] = tostring(weight),
        ["가슴"] = bust,
        ["유두"] = nipple,
        ["음모"] = pubes,
        ["페니스"] = penis,
        ["문신"]="",
        ["피어싱"]="",

        ["무기"] = classData.weapon, -- 한글
        ["방어구"] = classData.armor,
        ["장신구"]="없음",

        -- 특성 매핑: { "호기심": 1 } 형태
        -- assignedTraitsKey(영문) -> traitDB[key].name(한글)
        -- raceTraits(한글) -> 그대로 사용
        ["성격"] = {},
        ["신체특성"] = {},
        ["성적취향"] = {},
        ["칭호"] = "미함락",
        
        ["첫키스 상대"]="미경험", ["첫경험 상대"]="미경험", ["이상경험 기록"]={}
    }

    -- 특성 데이터 주입 함수
    local function injectTrait(korName)
        -- trait.db 전체를 뒤져서 카테고리를 찾아야 함?
        -- 아니면 assignedTraitsKey를 순회할 때 DB정보를 참조하므로 카테고리 알 수 있음.
        -- 하지만 종족특성(raceTraits)은 한글 이름만 있음.
        -- 역참조가 필요하거나, 그냥 모든 리스트를 다 뒤져야 함.
        -- -> traitDB는 평탄화 되어있으므로, name이 일치하는 것을 찾으면 됨.
        -- (효율성 문제: 매번 전체 순회? 캐시된 리스트 활용?)
        
        -- 개선안:
        -- 1. 영문키로 할당된 것들(assignedTraitsKey)은 traitDB[key].category 로 바로 분류 가능.
        -- 2. 한글키로 할당된 것들(raceTraits)은... 일단 '신체특성'이나 '성격' 중 하나일 텐데, DB 뒤져서 확인.
        
        for k, v in pairs(traitDB) do
            if v.name == korName then
                -- 카테고리에 맞게 삽입
                if not skeleton[v.category] then skeleton[v.category] = {} end
                --skeleton[v.category]는 객체가 아니라 배열이어야 하나? 
                -- charInfo.html 보면 {{dict_element::target::호기심}} == 1 체크함.
                -- 즉 target["호기심"] = 1 이어야 함? 
                -- *중요*: charInfo.html의 316라인: {{#if {{? {{dict_element::{{getvar::target}}::{{slot::T}}}} == 1}}}}
                -- 여기서 T는 '성격List'의 아이템(한글 이름).
                -- 즉 target 객체 바로 아래에 target["호기심"] = 1 이 있어야 함! (중첩 아님)
                -- 하지만 display용 리스트(skeleton["성격"])도 필요함?
                -- charInfo.html 315라인: {{#each {{getvar::성격List}} T}} -- 이건 전체 리스트 순회
                -- 그리고 target[T] == 1 인지 체크.
                -- 따라서 skeleton["호기심"] = 1 로 저장해야 함.
                -- skeleton["성격"] 필드는 사실상 필요 없을 수 있음 (HTML 로직상).
                -- 그러나 나중을 위해 분류해두는게 좋음?
                -- 일단 호환성을 위해 **최상위 레벨에 특성 키=1 저장** 필수.
                
                skeleton[korName] = 1
                return
            end
        end
        -- DB에 없으면(예: 오타) 그냥 최상위에 1로 저장
        skeleton[korName] = 1
    end

    -- 1. 랜덤 선택된 특성 주입
    for _, key in ipairs(assignedTraitsKey) do
        local tData = traitDB[key]
        if tData then
            skeleton[tData.name] = 1
        end
    end
    
    -- 2. 종족 특성 주입
    for _, korName in ipairs(raceTraitKeys) do
        injectTrait(korName)
    end
    
    
    debug("기초데이터", json.encode(skeleton))
    
    -- 6. LLM 요청
    local prompt = {
        promptBuild("system", getLoreBookContent(triggerId, "newChar.pt")),
        promptBuild("system", "existing names: "..getChatVar(triggerId, "chars")),
        promptBuild("user", json.encode(skeleton))
    }
    
    debug("신규 용사 생성 요청...")
    
    local response = LLM(triggerId, prompt, "newChar")
    if not response.success then
        alertError(triggerId, "용사 생성 실패 (LLM Error)")
        return
    end
    
    local content = response.result
    content = content:gsub("<Thoughts>.-</Thoughts>", "") 
    local narrative = json.decode(content:match("({.*})"))
    
    -- 7. 데이터 병합
    for k, v in pairs(narrative) do
        skeleton[k] = v
    end

    -- DB에 없는 필드 0으로 초기화 (abl, mark, exp, stat 등)
    -- stat.db도 초기화해야 함
    local extraDBs = {"mark.db", "abl.db", "exp.db", "stat.db"}
    for _, dbName in ipairs(extraDBs) do
        local dbContent = getDB(triggerId, dbName) -- 객체
        for key, val in pairs(dbContent) do
            -- 여기서도 한글 매핑 필요. charInfo.html 등에서 한글 키로 접근할 것임.
            -- 예: target["C쾌락"]
            if val.name then
                if not skeleton[val.name] then skeleton[val.name] = "0" end
            else
                if not skeleton[key] then skeleton[key] = "0" end
            end
        end
    end

    -- Trace 초기화
    local allTrace = getState(triggerId, "trace") or {}
    local traceDB = getDB(triggerId, "trace.db")
    allTrace[skeleton["이름"]] = {}
    
    for k, v in pairs(traceDB) do
        if v.name then
            allTrace[skeleton["이름"]][v.name] = 0
        end
    end
    setState(triggerId, "trace", allTrace)
    
    -- 캐릭터 리스트 업데이트
    local chars = json.decode(getChatVar(triggerId, "chars"))
    table.insert(chars, skeleton["이름"])
    setChatVar(triggerId, "chars", json.encode(chars))
    
    -- 로어북 저장
    upsertLocalLoreBook(triggerId, skeleton["이름"], json.encode(skeleton), DEFAULT_LORE_OPTION)
    
    debug("신규 용사 생성 완료", skeleton["이름"])
    
    if getState(triggerId, "screen") == "charList" then
        sysFunction(triggerId, "makeCharList.sys")
    end
end