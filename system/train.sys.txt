-- train.sys.txt
-- 조교 액션 및 로직 통합 모듈
-- 사용법: sysFunction(triggerId, "train.sys", "action", trainKey, actor)
--         sysFunction(triggerId, "train.sys", "insertionLogic", trainData, actor, difficulty)
--         sysFunction(triggerId, "train.sys", "tagMatch", tags, hasTags, notTags)

(function()
    ---------------------------------------
    -- 로컬 함수 정의
    ---------------------------------------

    -- 태그 매칭 로직
    local function tagMatch(triggerId, tags, hasTags, notTags)
        -- hasTags 검사: 모두 있어야 함
        if hasTags then
            for _, requiredTag in ipairs(hasTags) do
                local found = false
                for _, tag in ipairs(tags) do
                    if tag == requiredTag then
                        found = true
                        break
                    end
                end
                if not found then
                    return false
                end
            end
        end

        -- notTags 검사: 하나라도 있으면 실패
        if notTags then
            for _, excludeTag in ipairs(notTags) do
                for _, tag in ipairs(tags) do
                    if tag == excludeTag then
                        return false
                    end
                end
            end
        end
        return true
    end

    -- 삽입 로직: DC, feeling, command 보정
    local function insertionLogic(triggerId, trainData, actor, difficulty)
        local insertion = trainData.insertion
        if not insertion then
            return {
                dc = trainData.baseDC,
                feeling = trainData.feeling or 0,
                command = trainData.command,
                exps = trainData.exps,
                tooTight = false
            }
        end

        -- actor 데이터 로드
        local actorData = json.decode(getChatVar(triggerId, actor))
        local target = getState(triggerId, "target")
        local penis = actorData["페니스"]

        -- 확장도 속성
        local expandAttr = insertion.target -- "V확장", "A확장" 등
        local expandLv = expandAttr and tonumber(target[expandAttr]) or 10

        -- 페니스 크기 매핑
        local penisSize = {
            ["실좆"] = 1,
            ["작음"] = 2,
            ["평범"] = 3,
            ["대물"] = 4,
            ["말자지"] = 5
        }
        local pSize = penisSize[penis] or 3

        -- 필요 확장도 = (페니스크기 × 난이도) - 1
        local reqExpand = (pSize * difficulty) - 1

        local dc = trainData.baseDC
        local feeling = trainData.feeling or 0
        local command = trainData.command
        local exps = {}
        for _, v in ipairs(trainData.exps or {}) do
            table.insert(exps, v)
        end
        local tooTight = false

        -- 확장도 부족 시: DC 증가, command 추가, 확장경험 추가
        if expandLv < reqExpand then
            local gap = reqExpand - expandLv
            dc = dc + (gap * difficulty) -- 난이도 배수 적용
            tooTight = true

            local typeKor = { V = "질", A = "애널", U = "요도", M = "입" }
            command = command .. " {{user}}의 것이 들어가기에 {target}의 "
                .. (typeKor[insertion.type] or "") .. "은 너무 좁다."

            if insertion.type ~= "M" then
                table.insert(exps, insertion.type .. "확장경험")
            end
        end

        -- 확장도 여유 시: Feeling 감소
        local looseGap = math.max(0, expandLv - reqExpand)
        if looseGap > 0 then
            feeling = feeling - math.floor(looseGap * 0.5)
            feeling = math.max(0, feeling) -- 음수 방지
        end

        return {
            dc = dc,
            feeling = feeling,
            command = command,
            exps = exps,
            tooTight = tooTight
        }
    end

    -- 조교 액션 처리
    local function action(triggerId, trainKey, actor)
        actor = actor or "user"

        -- train.db 로드
        local trainDB = getDB(triggerId, "train.db")
        local trainData = trainDB[trainKey]

        if not trainData then
            alertNormal(triggerId, "train.db에서 '" .. trainKey .. "'를 찾을 수 없습니다.")
            return false
        end

        local target = getState(triggerId, "target")
        local stat = getState(triggerId, "stat")
        local tags = trainData.tags or {}

        --[[1. DC 계산]]
        local dc = DC_PENALTY * trainData.baseDC

        -- customEvent: onDCCalc 발동
        local ctx = { dc = dc, tags = tags, stat = stat, category = trainData.category, target = target }
        ctx = sysFunction(triggerId, "customEvent.sys", "onDCCalc", ctx)
        dc = ctx.dc

        --[[2. 비용 계산]]
        local costHP = trainData.costHP
        local costSP = trainData.costSP

        -- customEvent: onCostCalc 발동
        ctx = { costHP = costHP, costSP = costSP, tags = tags, stat = stat, target = target }
        ctx = sysFunction(triggerId, "customEvent.sys", "onCostCalc", ctx)
        costHP = ctx.costHP
        costSP = ctx.costSP

        --[[3. 경험치 및 커맨드]]
        local exps = {}
        for _, v in ipairs(trainData.exps or {}) do
            table.insert(exps, v)
        end
        local feeling = trainData.feeling or 0
        local command = trainData.command

        --[[4. 삽입 로직 처리]]
        if trainData.insertion then
            local difficulty = trainData.insertion.difficulty or 1
            -- 내부 로컬 함수 호출
            local insertResult = insertionLogic(triggerId, trainData, actor, difficulty)
            dc = dc + (insertResult.dc - trainData.baseDC)
            feeling = insertResult.feeling
            command = insertResult.command
            exps = insertResult.exps
        end

        --[[5. 장비 토글 커맨드 처리]]
        if trainData.equipment then
            local equipments = json.decode(getChatVar(triggerId, "equipments"))
            if equipments[trainData.equipment] == "착용" then
                command = trainData.commands.unequip or command
            else
                command = trainData.commands.equip or command
            end
        end

        -- 커맨드에서 {target} 치환
        command = command:gsub("{target}", target["이름"])

        --[[6. trainProcess.sys 호출]]
        --[[6. trainProcess.sys 호출]]
        sysFunction(triggerId, "trainProcess.sys", dc, costHP, costSP, exps, feeling, command, trainData.equipment, tags)
    end

    -- 절정치 계산 (orgasmCalc.sys 통합)
    local function orgasm(triggerId, who, statEXP, feeling, tags)
        local ORGASM_MAX_DEFAULT = 10000
        local ORGASM_MULTIPLIER = 1.2
        local DECAY_RATE = 0.95

        local countVar = "ej_" .. who .. "_count"
        local ratioVar = "ej_" .. who .. "_ratio"

        local count = tonumber(getChatVar(triggerId, countVar)) or 0
        local maxVal = ORGASM_MAX_DEFAULT * (ORGASM_MULTIPLIER ^ count)
        local ratio = tonumber(getChatVar(triggerId, ratioVar)) or 0
        ratio = math.floor(ratio * DECAY_RATE) -- 자연감소
        local current = math.floor(ratio * maxVal * 0.01)

        if who == "target" then
            local target = getState(triggerId, "target")

            -- 쾌락 stat으로 증가
            local plusStats = { "C쾌락", "V쾌락", "A쾌락", "B쾌락", "U쾌락", "M쾌락", "S쾌락" }
            for _, s in ipairs(plusStats) do
                current = current + (statEXP[s] or 0)
            end

            -- 부정 stat으로 감소
            local minusStats = { "공포", "불쾌", "부정" }
            for _, s in ipairs(minusStats) do
                current = current - (statEXP[s] or 0)
            end

            -- 조건부 stat (abl에 따라 + 또는 -)
            -- 굴복: 복종각인 있거나 봉사기술 > 4면 +
            local ejCon = statEXP["굴복"] or 0
            if tonumber(target["복종각인"] or 0) > 0 or tonumber(target["봉사기술"] or 0) > 4 then
                current = current + ejCon
            else
                current = current - ejCon
            end

            -- 수치: 노출벽 > 4면 +
            ejCon = statEXP["수치"] or 0
            if tonumber(target["노출벽"] or 0) > 4 then
                current = current + ejCon
            else
                current = current - ejCon
            end

            -- 고통: 마조끼 > 4면 +
            ejCon = statEXP["고통"] or 0
            if tonumber(target["마조끼"] or 0) > 4 then
                current = current + ejCon
            else
                current = current - ejCon
            end

            -- onOrgasmCalc 이벤트 발동
            local ctx = {
                orgasm = current,
                statEXP = statEXP,
                tags = tags or {},
                target = target
            }
            ctx = sysFunction(triggerId, "customEvent.sys", "onOrgasmCalc", ctx)
            current = ctx.orgasm
        elseif who == "user" then
            -- user는 feeling으로만 증가
            current = current + (feeling or 0) * ORGASM_MAX_DEFAULT * 0.01
        end

        -- 최대/최소 클램핑
        current = math.min(maxVal, math.max(0, math.floor(current)))
        local newRatio = current / maxVal * 100

        -- 절정 여부 체크
        local isOrgasm = false
        if current >= maxVal then
            isOrgasm = true
            count = count + 1
            newRatio = 0
        end

        -- 변수 저장
        setChatVar(triggerId, countVar, count)
        setChatVar(triggerId, ratioVar, string.format("%.2f", newRatio))

        return {
            isOrgasm = isOrgasm,
            count = count,
            ratio = newRatio
        }
    end

    -- 조교 종료 처리 (postTrain.sys 통합)
    local function post(triggerId)
        local target = getState(triggerId, "target")   --조교 종료시의 캐릭터 정보를 호출
        local exp = getDB(triggerId, "EXPtable.db")    --경험치 테이블 호출
        local allTraces = getState(triggerId, "trace") --모든 대상의 trace을 호출
        local traceCurrent = allTraces[target["이름"]] or {}
        local totalTrace = 0                           --spirit으로 전환할 trace 합계

        -- traceDB 로드 (유효한 흔적 키인지 확인용)
        local traceDB = getDB(triggerId, "trace.db")
        local validTraces = {}
        for k, v in pairs(traceDB) do
            if v.name then validTraces[v.name] = true end
        end

        --조교 종료시의 stat레벨에 따라 traceEXP를 저장 (stat은 한글 키)
        local stat = getState(triggerId, "stat")
        local traceEXP = {}

        for k, v in pairs(stat) do
            local val = tonumber(v)
            if val > 0 then
                local lvMin = tostring(val - 1)
                local minExp = exp[lvMin] or 0
                local maxExp = exp[tostring(val)] or 0

                if maxExp > 0 then
                    traceEXP[k] = math.random(minExp, maxExp) --stat 경험치를 랜덤하게 얻되 범위는 stat레벨-1에서 현재 레벨까지로 설정
                else
                    traceEXP[k] = 0
                end

                if traceEXP[k] == 0 then
                    traceEXP[k] = nil                     --traceEXP를 1이상 얻지못하면 테이블에서 제거
                else
                    totalTrace = totalTrace + traceEXP[k] --traceEXP를 획득하면 totalTrace에 합산
                end
            end
        end
        debug("traceEXP: " .. json.encode(traceEXP))

        --traceEXP에 따라 trace을 획득
        local statDB = getDB(triggerId, "stat.db")
        -- statDB 역매핑 (Name -> Related List)
        local statDBMap = {}
        for k, v in pairs(statDB) do
            if v.name then statDBMap[v.name] = v.related end
        end

        local traceAdd = {}
        local traceSum = {}

        -- traceSum 초기화 (traceCurrent 복사)
        for k, v in pairs(traceCurrent) do
            traceSum[k] = v
        end

        local traceSort = {}

        for k, val in pairs(traceEXP) do -- trace획득량 계산 (k는 한글 스탯명)
            local relatedList = statDBMap[k]
            if relatedList and #relatedList > 0 then
                local len = #relatedList
                local totalWeight = len * (len + 1) * 0.5 -- 1부터 len까지 합 (가중치 총합)

                for i, traceName in ipairs(relatedList) do
                    -- 유효한 흔적 이름인지 확인
                    if validTraces[traceName] then
                        -- 가중치: 목록의 앞에 있을수록 높음 (len, len-1, ..., 1)
                        local weight = len - i + 1
                        local addAmount = math.floor(val * weight / totalWeight)

                        traceAdd[traceName] = addAmount
                        traceSum[traceName] = (traceSum[traceName] or 0) + addAmount
                    end
                end
            end
        end

        --부정이 0보다 큰 경우에만 차감로직 실행
        local deductLevel = 0 --각 흔적에서 차감하게 될 양
        local deduct = traceSum["부정"] or 0 --차감 대상 부정구슬의 양
        local deductSum = 0 --실제 차감한 부정 구슬의 합계

        if deduct > 0 then
            --traceSort에 부정을 제외한 0이상의 흔적 입력
            for k, v in pairs(traceSum) do
                if k ~= "부정" and v > 0 then
                    table.insert(traceSort, v)
                end
            end

            --traceSort 오름차순 정렬
            table.sort(traceSort)

            --deductLevel계산
            for i, v in ipairs(traceSort) do
                local len = #traceSort - i + 1 --남은 차감 대상의 수
                local cost = v - deductLevel   --현재 단계에서 차감해야할 비용

                if cost > 0 then
                    local sub = cost * len    --현재 단계에서 필요한 총비용
                    if deduct >= sub then     --부정구슬이 남으면
                        deduct = deduct - sub --부정구슬에서 현재단계 필요비용만큼 차감
                        deductSum = deductSum + sub
                        deductLevel = v
                    else --안남으면 for문 중단
                        local delta = math.floor(deduct / len)
                        deductLevel = deductLevel + delta
                        deductSum = deductSum + delta * len
                        break
                    end
                end
            end
        end

        --실제 흔적에 획득/차감 반영
        local traceText = "조교로부터 " .. intForm(totalTrace) .. " Spirit을 획득했습니다.<br>"
        for k, v in pairs(traceSum) do
            local pp = traceAdd[k] or 0
            local mm = 0
            if k ~= "부정" then
                mm = math.min(deductLevel, v)
            end

            --trace 변동 텍스트
            if pp ~= 0 or mm ~= 0 or (k == "부정" and deductSum > 0) then
                if k == "부정" then
                    traceText = traceText ..
                        k ..
                        ": " ..
                        (traceCurrent[k] or 0) ..
                        " + " .. pp .. " - " .. deductSum .. " = " .. (traceCurrent[k] or 0) + pp - deductSum .. "<br>"
                else
                    traceText = traceText ..
                        k ..
                        ": " ..
                        (traceCurrent[k] or 0) ..
                        " + " .. pp .. " - " .. mm .. " = " .. (traceCurrent[k] or 0) + pp - mm .. "<br>"
                end
            end

            --traceCurrent에 변동값 반영
            if k == "부정" then
                traceCurrent[k] = (traceCurrent[k] or 0) + (traceAdd[k] or 0) - deductSum
            else
                traceCurrent[k] = math.max((traceCurrent[k] or 0) + (traceAdd[k] or 0) - deductLevel, 0)
            end
        end

        --조교로 얻은 spirit 합산
        local spirit = tonumber(getChatVar(triggerId, "spirit") or "0") --기존 값이 "10,000" 형태라면 tonumber 실패 가능성 -> intForm 역함수 필요하나 로직상 숫자 문자열 가정
        -- initVars에서 "10,000"으로 초기화함. 쉼표 제거 필요.
        if type(getChatVar(triggerId, "spirit")) == "string" then
            spirit = tonumber((getChatVar(triggerId, "spirit"):gsub(",", ""))) or 0
        end

        spirit = intForm(spirit + totalTrace)
        setChatVar(triggerId, "spirit", spirit)

        --조교로 변경된 target값을 로어북에 업데이트
        upsertLocalLoreBook(triggerId, target["이름"], json.encode(target), DEFAULT_LORE_OPTION)
        stateToVar(triggerId, "target", target)

        --갱신된 trace 정보를 변수에 업데이트
        stateToVar(triggerId, "targetTrace", traceCurrent)
        allTraces[target["이름"]] = traceCurrent
        setState(triggerId, "trace", allTraces)
        setChatVar(triggerId, "traceText", traceText)

        --조교 로그를 저장후 신규 챗 인덱스에 게임 화면 생성
        addChat(triggerId, "user", "{{" .. "getvar::html" .. "}}")
        local ampm = getChatVar(triggerId, "ampm")
        if ampm == "0" then ampm = "낮" else ampm = "밤" end
        local lastTrainLog =
            "<div class='showLog' style='visibility: {{#when::showLog::vis::1}}visible{{:else}}hidden{{/when}};'><p>" ..
            getChatVar(triggerId, "day") ..
            "일차 " ..
            ampm ..
            " / 조교 대상:" ..
            target["이름"] ..
            "</p><p>" .. getChatVar(triggerId, "oldLog") .. getChatVar(triggerId, "newLog") .. "</p></div>"
        setChat(triggerId, getChatLength(triggerId) - 2, lastTrainLog)

        --정보 초기화
        setChatVar(triggerId, "selectedAbl", "none")
        --조교후 화면으로 이동
        screenChange(triggerId, "ablUp")
    end

    -- 조교 초기 설정 (preTrainSetting.sys 통합)
    local function prepare(triggerId, name)
        --target를 로어북에서 불러와 1차원으로 flatten
        local target = json.decode(getLoreBookContent(triggerId, name))
        setState(triggerId, "target", target) --대상 캐릭터 로어북 정보를 state에 저장
        target = flatten(target)
        local day = getChatVar(triggerId, "day")
        local ampm = tonumber(getChatVar(triggerId, "ampm"))
        local date = day .. "일째, "
        if ampm == 0 then
            date = date .. "낮"
        else
            date = date .. "밤"
        end

        --조교경험 추가
        target["조교회수"] = tostring(target["조교회수"] + 1)

        --조교화면 변수 초기화
        setChatVar(triggerId, "category", "애무계")
        setChatVar(triggerId, "oldLog", date .. " ")
        setChatVar(triggerId, "newLog", "[" .. target["이름"] .. "의 " .. target["조교회수"] .. "번째 조교]<br>")
        setChatVar(triggerId, "statLvUp", " ")
        setChatVar(triggerId, "ej_target_ratio", 0) --조교대상 절정치
        setChatVar(triggerId, "ej_user_ratio", 0) --유저 절정치
        setChatVar(triggerId, "요의", 0) --조교대상 요의
        setChatVar(triggerId, "ej_target_count", 0) --조교대상 절정 회수 초기화
        setChatVar(triggerId, "ej_user_count", 0) --유저 절정 회수 초기화
        setChatVar(triggerId, "statFold", "0") --stat 세부 내역이 보이도록 초기화
        setChatVar(triggerId, "equipments", getLoreBookContent(triggerId, "equipments.db")) --착용품 모두 미착용으로 초기화

        --수정구 영상 초기화
        TRAIN_REC = 0
        setState(triggerId, "recLog", "")

        --스탯 초기화 (캐싱 메커니즘 사용)
        local statDB = getDB(triggerId, "stat.db")
        local stat = {}
        for k, v in pairs(statDB) do
            -- statBonus 등이 한글 키를 사용하므로 한글 이름으로 초기화
            if v.name then
                stat[v.name] = 0
            else
                stat[k] = 0
            end
        end

        --stat에 영향을 주는 모든 속성을 나열한 후 대상 캐릭터의 데이터를 모두 순회하며 stat에 영향을 주는 항목이 있는지 체크
        --abl같은 특정테이블만 순회하는것보다 확장성이 뛰어남
        local ablBase = 0.2  --abl*ablBase가 stat의 최소치를 보장해 높은 abl의 효과를 보장하도록 함
        local ablRatio = 0.5 --abl*ablRatio*math.random()을 더해 매 조교마다 조금씩 다른 stat치로 시작하도록 함
        local statBonus = {  --한글키값을 넣기위해 ["키값"]구조 적용
            --abl
            ["C감각"] = function(v)
                stat["C쾌락"] = stat["C쾌락"] + v * (ablBase + ablRatio * math.random()) --자동 형변환 하겠지..
            end,
            ["B감각"] = function(v)
                stat["B쾌락"] = stat["B쾌락"] + v * (ablBase + ablRatio * math.random())
            end,
            ["V감각"] = function(v)
                stat["V쾌락"] = stat["V쾌락"] + v * (ablBase + ablRatio * math.random())
            end,
            ["A감각"] = function(v)
                stat["A쾌락"] = stat["A쾌락"] + v * (ablBase + ablRatio * math.random())
            end,
            ["U감각"] = function(v)
                stat["U쾌락"] = stat["U쾌락"] + v * (ablBase + ablRatio * math.random())
            end,
            ["M감각"] = function(v)
                stat["M쾌락"] = stat["M쾌락"] + v * (ablBase + ablRatio * math.random())
            end,
            ["V확장"] = function(v) --확장이 높아지면 쾌감이 감소
                stat["V쾌락"] = stat["V쾌락"] - v * (ablBase + ablRatio * math.random()) * 0.5
                stat["V윤활"] = stat["V윤활"] + v * (ablBase + ablRatio * math.random()) * 1.5
            end,
            ["A확장"] = function(v) --확장이 높아지면 쾌감이 감소
                stat["A쾌락"] = stat["A쾌락"] - v * (ablBase + ablRatio * math.random()) * 0.5
                stat["A윤활"] = stat["A윤활"] + v * (ablBase + ablRatio * math.random()) * 1.5
            end,
            ["U확장"] = function(v) --확장이 높아지면 쾌감이 감소. 요도의 경우에는 확장되지 않으면 할 수 있는게 적으므로 페널티 감소
                stat["U쾌락"] = stat["U쾌락"] - v * (ablBase + ablRatio * math.random()) * 0.2
                stat["V윤활"] = stat["V윤활"] + v * (ablBase + ablRatio * math.random()) * 1.2 --V윤활이라도 올려줘야..
            end,
            ["순종"] = function(v)
                stat["온순"] = stat["온순"] + v * (ablBase + ablRatio * math.random())
            end,
            ["욕망"] = function(v)
                stat["욕정"] = stat["욕정"] + v * (ablBase + ablRatio * math.random())
            end,
            ["봉사기술"] = function(v)
                stat["굴복"] = stat["굴복"] + v * (ablBase + ablRatio * math.random()) * 0.5
                stat["온순"] = stat["온순"] + v * (ablBase + ablRatio * math.random()) * 0.25
                stat["습득"] = stat["습득"] + v * (ablBase + ablRatio * math.random()) * 0.25
            end,
            ["성교기술"] = function(v)
                stat["욕정"] = stat["욕정"] + v * (ablBase + ablRatio * math.random()) * 0.2
                stat["습득"] = stat["습득"] + v * (ablBase + ablRatio * math.random()) * 0.2
                stat["온순"] = stat["온순"] + v * (ablBase + ablRatio * math.random()) * 0.1
                stat["C쾌락"] = stat["C쾌락"] + v * (ablBase + ablRatio * math.random()) * 0.1
                stat["V쾌락"] = stat["V쾌락"] + v * (ablBase + ablRatio * math.random()) * 0.1
                stat["A쾌락"] = stat["A쾌락"] + v * (ablBase + ablRatio * math.random()) * 0.1
                stat["B쾌락"] = stat["B쾌락"] + v * (ablBase + ablRatio * math.random()) * 0.1
                stat["V윤활"] = stat["V윤활"] + v * (ablBase + ablRatio * math.random()) * 0.1
            end,
            ["노출벽"] = function(v)
                stat["굴복"] = stat["굴복"] + v * (ablBase + ablRatio * math.random()) * 0.5
                stat["수치"] = stat["수치"] + v * (ablBase + ablRatio * math.random()) * 0.5
            end,
            ["마조끼"] = function(v)
                stat["굴복"] = stat["굴복"] + v * (ablBase + ablRatio * math.random()) * 0.5
                stat["고통"] = stat["고통"] + v * (ablBase + ablRatio * math.random()) * 0.5
            end,

            --trait_체질
            ["성교중독"] = function(v)
                stat["온순"] = stat["온순"] + 0.5
                stat["V쾌락"] = stat["V쾌락"] + 0.25
                stat["A쾌락"] = stat["A쾌락"] + 0.25
            end,
            ["자위중독"] = function(v)
                stat["온순"] = stat["온순"] + 0.5
                stat["V윤활"] = stat["V윤활"] + 0.5
                stat["A윤활"] = stat["A윤활"] + 0.5
            end,
            ["정액중독"] = function(v)
                stat["굴복"] = stat["굴복"] + 0.5
                stat["습득"] = stat["습득"] + 0.5
            end,
            ["매춘중독"] = function(v)
                stat["온순"] = stat["온순"] + 0.5
            end,
            ["방뇨중독"] = function(v)
                stat["수치"] = stat["수치"] + 1.5
                stat["불쾌"] = stat["불쾌"] + 0.5
            end,
            ["촉수중독"] = function(v)
                stat["온순"] = stat["온순"] + 0.5
            end,
            ["수간중독"] = function(v)
                stat["온순"] = stat["온순"] + 0.5
            end,
            ["상시발정"] = function(v)
                stat["V윤활"] = stat["V윤활"] + 1
            end,

            --trait_칭호
            ["음란"] = function(v)
                stat["V윤활"] = stat["V윤활"] + 2
                stat["욕정"] = stat["욕정"] + 3
            end,
            ["연모"] = function(v)
                stat["온순"] = stat["온순"] + 5
            end,
            ["암캐"] = function(v)
                stat["C쾌락"] = stat["C쾌락"] + 1
                stat["V쾌락"] = stat["V쾌락"] + 1
                stat["A쾌락"] = stat["A쾌락"] + 1
                stat["B쾌락"] = stat["B쾌락"] + 1
                stat["욕정"] = stat["욕정"] + 1
            end,
            ["붕괴"] = function(v)
                stat["공포"] = stat["공포"] + 5
            end,
            ["광기"] = function(v)
                stat["부정"] = stat["부정"] + 5
            end,

            --mark
            ["고통각인"] = function(v)
                stat["고통"] = stat["고통"] + v * 1
            end,
            ["쾌락각인"] = function(v)
                stat["욕정"] = stat["욕정"] + v * 1
            end,
            ["공포각인"] = function(v)
                stat["공포"] = stat["공포"] + v * 1
            end,
            ["복종각인"] = function(v)
                stat["온순"] = stat["온순"] + v * 1
            end,
            ["치욕각인"] = function(v)
                stat["굴복"] = stat["굴복"] + v * 1
            end,
            ["반발각인"] = function(v)
                stat["저항"] = stat["저항"] + v * 2
            end
        }

        --평탄화된 target테이블을 순회하며 statBonus 적용
        for k, v in pairs(target) do
            local v = tonumber(v) or v
            if v ~= 0 then
                local suc, _ = pcall(statBonus[k], v)
                if suc then
                    -- print(k.."보너스 적용") -- debug removed or kept
                end
            end
        end

        --stat을 정수화하고 0~10사이에 있도록 제한
        for k, v in pairs(stat) do
            stat[k] = math.min(math.max(math.floor(v), 0), 10)
        end
        setState(triggerId, "target", target)
        stateToVar(triggerId, "target", target) --대상 캐릭터를 챗변수에 저장
        setState(triggerId, "stat", stat)       --계산된 stat를 state에 저장
        --챗변수를 위한 사전처리
        local stat_c = "{"
        for k, v in pairs(stat) do
            stat_c = stat_c .. '"' .. k .. '":"' .. v .. '",'
        end
        stat_c = string.gsub(stat_c, ",$", "}") -- 마지막 쉼표 대신 중괄호 닫기
        setChatVar(triggerId, "stat", stat_c)   --가공된 stat을 챗변수에 저장
    end

    ---------------------------------------
    -- 디스패처 테이블
    ---------------------------------------
    local funcs = {
        action = action,
        insertionLogic = insertionLogic,
        tagMatch = tagMatch,
        orgasm = orgasm,
        post = post,
        prepare = prepare
    }

    ---------------------------------------
    -- 메인 함수 (외부에서 호출됨)
    ---------------------------------------
    return function(triggerId, subFunc, ...)
        if funcs[subFunc] then
            return funcs[subFunc](triggerId, ...)
        else
            debug("train.sys: 알 수 없는 함수 - " .. tostring(subFunc))
        end
    end
end)()
