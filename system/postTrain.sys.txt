function (triggerId)
    local target = getState(triggerId, "target") --조교 종료시의 캐릭터 정보를 호출
    local exp = json.decode(getLoreBookContent(triggerId, "EXPtable.db")) --경험치 테이블 호출
    local allTraces = getState(triggerId, "trace") --모든 대상의 trace을 호출
    local traceCurrent = allTraces[target["이름"]]
    local traceDB = json.decode(getLoreBookContent(triggerId, "trace.db")) --흔적 리스트를 trace.db에서 호출

    --조교 종료시의 stat레벨에 따라 traceEXP를 저장
    local stat = getState(triggerId, "stat")
    local traceEXP = {}

    for k, v in pairs(stat) do
        if tonumber(v) > 0 then
            local lvMin = tostring(v-1)
            traceEXP[k] = math.random(exp[lvMin], exp[tostring(v)]) --stat 경험치를 랜덤하게 얻되 범위는 stat레벨-1에서 현재 레벨까지로 설정
            if traceEXP[k] == 0 then traceEXP[k] = nil end --traceEXP를 1이상 얻지못하면 테이블에서 제거
        end
    end
    debug("traceEXP: "..json.encode(traceEXP))
    --traceEXP에 따라 trace을 획득
    local statDB = json.decode(getLoreBookContent(triggerId, "stat.db"))
    local traceAdd = {}
    local traceSum = {}
    for k, v in pairs(traceCurrent) do --deep copy
        traceSum[k] = v
    end
    local traceSort = {}
    for k, v in pairs(traceEXP) do --trace획득량 계산
        local db = statDB[k]
        local len = #db

        for i, j in ipairs(db) do
            local total = (len-1)*len*0.5 --설명배열이 하나 있으므로 1~len-1까지의 값을 합산
            if traceDB[j] then
                traceAdd[j] = math.floor(traceEXP[k]*(len-i+1)/total) --앞쪽에 위치한 trace부터 더 높은 가중치로 exp를 분배
                traceSum[j] = traceCurrent[j] + traceAdd[j]
            end
        end
    end

    --부정이 0보다 큰 경우에만 차감로직 실행
    local deductLevel = 0 --각 흔적에서 차감하게 될 양
    local deduct = traceSum["부정"] --차감 대상 부정구슬의 양
    local deductSum = 0 --실제 차감한 부정 구슬의 합계
    if deduct > 0 then

        debug("init"..json.encode(traceCurrent))
        debug("add"..json.encode(traceAdd))
        debug("sum"..json.encode(traceSum))
        --traceSort에 부정을 제외한 0이상의 흔적 입력
        for k, v in pairs(traceSum) do
            if k ~= "부정" then
                table.insert(traceSort, v)
            end
        end

        --traceSort 오름차순 정렬
        table.sort(traceSort, function(a, b)
            return a < b
        end)

        --deductLevel계산
        for i, v in ipairs(traceSort) do
            local len = #traceSort - i + 1 --남은 차감 대상의 수
            local cost = v - deductLevel --현재 단계에서 차감해야할 비용
            local sub = cost * len --현재 단계에서 필요한 총비용
            if deduct >= sub then --부정구슬이 남으면
                deduct = deduct - sub --부정구슬에서 현재단계 필요비용만큼 차감
                deductSum = deductSum + sub
                deductLevel = v
            else --안남으면 for문 중단
                local delta = math.floor(deduct/len)
                deductLevel = deductLevel + delta
                deductSum = deductSum + delta*len
                break
            end
        end
        debug("최초부정: "..traceCurrent["부정"])
        debug("증가부정: "..(traceAdd["부정"] or 0))
        debug("합계부정: "..traceSum["부정"])
    end

    --실제 흔적에 획득/차감 반영
    local traceText = ""
    for k, v in pairs(traceSum) do
        local pp = traceAdd[k] or 0
        local mm = math.min(deductLevel, v)

        --trace 변동 텍스트
        if pp ~= 0 or mm ~= 0 then
            if k =="부정" then
                traceText = traceText .. k ..": " .. traceCurrent[k] .. " + " .. pp .. " - " .. deductSum .. " = " .. traceCurrent[k]+pp-deductSum .. "<br>"
            else
                traceText = traceText .. k ..": " .. traceCurrent[k] .. " + " .. pp .. " - " .. mm .. " = " .. traceCurrent[k]+pp-mm .. "<br>"
            end
        end
        --traceCurrent에 변동값 반영
        if k =="부정" then
            traceCurrent[k] = traceCurrent[k] + (traceAdd[k] or 0) - deductSum
        else
            traceCurrent[k] = math.max(traceCurrent[k] + (traceAdd[k] or 0) - deductLevel, 0)
        end
    end

    --조교로 변경된 target값을 로어북에 업데이트
    local option = {alwaysActive = false, insertOrder = 100, key = "", secondKey = "", regex = false}
    upsertLocalLoreBook(triggerId, target["이름"], json.encode(target), option)
    stateToVar(triggerId, "target", target)
    
    --갱신된 trace 정보를 변수에 업데이트
    stateToVar(triggerId, "targetTrace", traceCurrent)
    allTraces[target["이름"]] = traceCurrent
    setState(triggerId, "trace", allTraces)
    setChatVar(triggerId, "traceText", traceText)

    --조교 로그를 저장후 게임 화면 생성챗을 추가
    addChat(triggerId, "user", "{{".."getvar::html".."}}")
    local ampm = getChatVar(triggerId,"ampm")
    if ampm == 0 then ampm ="낮" else ampm="밤" end
    local lastTrainLog = "<div class='showLog'><p>"..getChatVar(triggerId,"day").."일차 "..ampm.." / 조교 대상:"..target["이름"].."</p><p>"..getChatVar(triggerId,"oldLog")..getChatVar(triggerId,"newLog").."</p></div>"
    setChat(triggerId, getChatLength(triggerId)-2, lastTrainLog)

    --정보 초기화
    setChatVar(triggerId, "selectedAbl", "none")
    --조교후 화면으로 이동
    setState(triggerId, "screen", "postTrain")
end